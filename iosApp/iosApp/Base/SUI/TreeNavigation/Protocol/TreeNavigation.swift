//
//  Navigatable.swift
//  iosApp
//
//  Created by Denis Dmitriev on 03.04.2025.
//

import SwiftUI

/**
 * Протокол для навигации с деревом компонентов, в котором каждый компонент может иметь дочерние элементы,
 * образующие иерархию навигации. Протокол предназначен для работы с компонентами, где навигация должна
 * быть основана на иерархической структуре (например, дерево экранов, с возможностью перехода между ними).
 *
 * Этот протокол требует реализации методов для определения, как строится навигация для конкретного типа
 * компонента, а также как отображать дочерние компоненты на основе текущего состояния навигации.
 *
 * Свойства:
 * - `childStack`: Состояние текущего стека дочерних компонентов.
 *
 * Методы:
 * - `destination(for:)`: Метод для определения представления для конкретного дочернего компонента.
 *
 * Типы:
 * - `Destination`: Тип компонента, который может быть использован в навигации.
 * - `Content`: Тип представления, которое отображается для компонента `Destination`.
 */
protocol TreeNavigation {
    /// Тип дочернего компонента, который будет использоваться в навигации.
    associatedtype Destination: AnyObject & Hashable
    /// Тип представления для компонента `Destination`.
    associatedtype Content: View
    
    /// Стек дочерних компонентов, хранящий текущие элементы навигации.
    var childStack: ObservableState<ChildStack<AnyObject, Destination>> { get set }
    
    /**
     * Метод для создания представления для конкретного дочернего компонента.
     *
     * Этот метод должен возвращать представление для навигации на основе текущего дочернего элемента.
     * Используется для построения UI на основе компонента в навигационном стеке.
     *
     * - Parameter item: Компонент типа `Destination`, для которого необходимо создать представление.
     * - Returns: Представление для компонента.
     */
    func destination(for item: Destination) -> Content
}

extension TreeNavigation {
    /// Исходное представление в массиве навигации или нулевой элемент массива
    @ViewBuilder var rootView: some View {
        if let value = childStack.value.items.compactMap({ $0.instance }).first {
            destination(for: value)
        } else {
            EmptyView()
        }
    }
}
